rules:
  # A. Avoid eval(...) — baseline sanity check
  - id: no-eval-demo
    languages: [javascript]
    message: Avoid eval(...) — executes arbitrary code
    severity: MEDIUM
    patterns:
      - pattern: eval($X)

  # B. Off-by-one loop: using "<=" with array.length
  # Matches typical for-loops that step with i++ | ++i and use <= length.
  - id: off-by-one-loop
    languages: [javascript]
    message: Possible off-by-one error — loop uses "<=" with array.length
    severity: HIGH
    patterns:
      - pattern: |
          for (let $I = 0; $I <= $ARR.length; $STEP) {
            ...
          }
      - metavariable-pattern:
          metavariable: $STEP
          pattern-either:
            - pattern: $I++
            - pattern: ++$I
            - pattern: $I += 1

  # C. Null/undefined access on a function parameter (demo-friendly)
  # Triggers when a function param is dereferenced without any local null check.
  - id: null-access-param
    languages: [javascript]
    message: Possible null/undefined access on parameter without a local check
    severity: HIGH
    patterns:
      - pattern: |
          function $F($X, ...) {
            ...
            $X.$PROP
            ...
          }
      # If there is a guard like: if ($X != null && $X !== undefined) { ... }
      # then suppress. (Keeps the demo realistic but deterministic.)
      - pattern-not: |
          function $F($X, ...) {
            ...
            if ($X != null && $X !== undefined) { ... }
            ...
          }

  # D. Insecure regex (classic ReDoS shape "(a+)+") in literal or constructor
  - id: insecure-regex-redos
    languages: [javascript]
    message: Potential ReDoS — nested quantifier like "(a+)+"
    severity: CRITICAL
    pattern-either:
      - pattern: /(a+)+/
      - pattern: new RegExp("(a+)+")
